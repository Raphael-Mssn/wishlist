

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pgsodium";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."friendship_status" AS ENUM (
    'accepted',
    'pending',
    'rejected',
    'blocked'
);


ALTER TYPE "public"."friendship_status" OWNER TO "postgres";


CREATE TYPE "public"."visibility" AS ENUM (
    'public',
    'private'
);


ALTER TYPE "public"."visibility" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."delete_user_account"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Supprimer l'utilisateur de auth.users
  -- Cela déclenchera automatiquement la suppression en cascade
  -- de toutes les données associées si les contraintes FK sont bien configurées
  DELETE FROM auth.users
  WHERE id = auth.uid();
END;
$$;


ALTER FUNCTION "public"."delete_user_account"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_friend_or_friend_of_friend"("_user_id" "uuid", "_friend_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM friendships
    WHERE (requester_id = _user_id AND receiver_id = _friend_id) OR
          (requester_id = _friend_id AND receiver_id = _user_id) OR
          (requester_id = _user_id AND receiver_id IN (
              SELECT CASE
                WHEN requester_id = _user_id THEN receiver_id
                ELSE requester_id
              END
              FROM friendships
              WHERE requester_id = _user_id OR receiver_id = _user_id
          )) OR
          (receiver_id = _user_id AND requester_id IN (
              SELECT CASE
                WHEN requester_id = _user_id THEN receiver_id
                ELSE requester_id
              END
              FROM friendships
              WHERE requester_id = _user_id OR receiver_id = _user_id
          ))
  );
END;
$$;


ALTER FUNCTION "public"."is_friend_or_friend_of_friend"("_user_id" "uuid", "_friend_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."nb_wishs_by_user"("user_id" "uuid") RETURNS bigint
    LANGUAGE "plpgsql"
    AS $$
DECLARE
    wish_count bigint;
BEGIN
    SELECT COUNT(*)
    INTO wish_count
    FROM wishlists
    JOIN wishs ON wishlists.id = wishs.wishlist_id
    WHERE wishlists.id_owner = user_id;

    RETURN wish_count;
END;
$$;


ALTER FUNCTION "public"."nb_wishs_by_user"("user_id" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_user_metadata"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Mettre à jour les metadata et display_name dans auth.users
  UPDATE auth.users
  SET 
    raw_user_meta_data = jsonb_set(
      jsonb_set(
        COALESCE(raw_user_meta_data, '{}'),
        '{pseudo}', 
        to_jsonb(NEW.pseudo)
      ),
      '{display_name}', 
      to_jsonb(NEW.pseudo)
    )
  WHERE id = NEW.id;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_user_metadata"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."friendships" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "status" "public"."friendship_status" DEFAULT 'pending'::"public"."friendship_status" NOT NULL,
    "requester_id" "uuid" NOT NULL,
    "receiver_id" "uuid" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

ALTER TABLE ONLY "public"."friendships" REPLICA IDENTITY FULL;


ALTER TABLE "public"."friendships" OWNER TO "postgres";


ALTER TABLE "public"."friendships" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."friendships_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "pseudo" "text",
    "avatar_url" "text"
);

ALTER TABLE ONLY "public"."profiles" REPLICA IDENTITY FULL;


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."users_profiles" AS
 SELECT "users"."id",
    "row_to_json"("users".*) AS "user",
    "row_to_json"("profiles".*) AS "profile"
   FROM ("auth"."users"
     JOIN "public"."profiles" ON (("users"."id" = "profiles"."id")));


ALTER TABLE "public"."users_profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wish_taken_by_user" (
    "user_id" "uuid" NOT NULL,
    "wish_id" bigint NOT NULL,
    "quantity" bigint DEFAULT '1'::bigint NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

ALTER TABLE ONLY "public"."wish_taken_by_user" REPLICA IDENTITY FULL;


ALTER TABLE "public"."wish_taken_by_user" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."wishlists" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "id_owner" "uuid" NOT NULL,
    "color" "text" NOT NULL,
    "icon_url" "text",
    "is_closed" boolean DEFAULT false NOT NULL,
    "end_date" timestamp with time zone,
    "can_owner_see_taken_wish" boolean DEFAULT false NOT NULL,
    "visibility" "public"."visibility" DEFAULT 'private'::"public"."visibility" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_by" "uuid" NOT NULL,
    "order" smallint DEFAULT '0'::smallint NOT NULL,
    CONSTRAINT "color_hex_constraint" CHECK (("color" ~ '^#[0-9A-Fa-f]{6}$'::"text"))
);

ALTER TABLE ONLY "public"."wishlists" REPLICA IDENTITY FULL;


ALTER TABLE "public"."wishlists" OWNER TO "postgres";


ALTER TABLE "public"."wishlists" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."wishlists_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."wishs" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text" NOT NULL,
    "price" double precision,
    "link_url" "text",
    "icon_url" "text",
    "is_favourite" boolean DEFAULT false NOT NULL,
    "quantity" bigint DEFAULT '1'::bigint NOT NULL,
    "wishlist_id" bigint NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_by" "uuid" NOT NULL
);

ALTER TABLE ONLY "public"."wishs" REPLICA IDENTITY FULL;


ALTER TABLE "public"."wishs" OWNER TO "postgres";


ALTER TABLE "public"."wishs" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."wishs_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



ALTER TABLE ONLY "public"."friendships"
    ADD CONSTRAINT "friendships_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pseudo_key" UNIQUE ("pseudo");



ALTER TABLE ONLY "public"."wish_taken_by_user"
    ADD CONSTRAINT "wish_taken_by_user_pkey" PRIMARY KEY ("user_id", "wish_id");



ALTER TABLE ONLY "public"."wishlists"
    ADD CONSTRAINT "wishlists_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."wishs"
    ADD CONSTRAINT "wishs_pkey" PRIMARY KEY ("id");



CREATE OR REPLACE TRIGGER "set_user_metadata" AFTER INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_metadata"();



ALTER TABLE ONLY "public"."friendships"
    ADD CONSTRAINT "friendships_profile_id_1_fkey" FOREIGN KEY ("requester_id") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."friendships"
    ADD CONSTRAINT "friendships_profile_id_2_fkey" FOREIGN KEY ("receiver_id") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wish_taken_by_user"
    ADD CONSTRAINT "wish_taken_by_profile_profile_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wish_taken_by_user"
    ADD CONSTRAINT "wish_taken_by_profile_wish_id_fkey" FOREIGN KEY ("wish_id") REFERENCES "public"."wishs"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wishlists"
    ADD CONSTRAINT "wishlists_id_owner_fkey" FOREIGN KEY ("id_owner") REFERENCES "public"."profiles"("id") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."wishs"
    ADD CONSTRAINT "wishs_wishlist_id_fkey" FOREIGN KEY ("wishlist_id") REFERENCES "public"."wishlists"("id") ON DELETE CASCADE;



CREATE POLICY "Allow insert for own profile" ON "public"."profiles" FOR INSERT WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Auth users can update their own profile" ON "public"."profiles" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "id")) WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Enable delete for users based on user_id" ON "public"."friendships" FOR DELETE USING (((( SELECT "auth"."uid"() AS "uid") = "requester_id") OR (( SELECT "auth"."uid"() AS "uid") = "receiver_id")));



CREATE POLICY "Enable delete for users based on user_id" ON "public"."wish_taken_by_user" FOR DELETE USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "Enable delete for users based on user_id" ON "public"."wishlists" FOR DELETE USING ((( SELECT "auth"."uid"() AS "uid") = "id_owner"));



CREATE POLICY "Enable delete for users based on user_id" ON "public"."wishs" FOR DELETE USING ((( SELECT "auth"."uid"() AS "uid") = ( SELECT "wl"."id_owner"
   FROM "public"."wishlists" "wl"
  WHERE ("wl"."id" = "wishs"."wishlist_id"))));



CREATE POLICY "Enable insert for authenticated users only" ON "public"."wish_taken_by_user" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."wishlists" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for authenticated users only" ON "public"."wishs" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Enable insert for users based on user_id" ON "public"."friendships" FOR INSERT WITH CHECK (((( SELECT "auth"."uid"() AS "uid") = "requester_id") OR (( SELECT "auth"."uid"() AS "uid") = "receiver_id")));



CREATE POLICY "Enable read access based on user_id" ON "public"."friendships" FOR SELECT TO "authenticated" USING ((("auth"."uid"() = "requester_id") OR ("auth"."uid"() = "receiver_id") OR ("public"."is_friend_or_friend_of_friend"("auth"."uid"(), "requester_id") OR "public"."is_friend_or_friend_of_friend"("auth"."uid"(), "receiver_id"))));



CREATE POLICY "Enable read access for authenticated users only" ON "public"."wish_taken_by_user" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Enable read access for authenticated users only" ON "public"."wishs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Enable read for authenticated users only" ON "public"."profiles" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Enable select for authenticated users only" ON "public"."wishlists" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Enable update for authenticated users based on user_id" ON "public"."wish_taken_by_user" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id")) WITH CHECK (true);



CREATE POLICY "Enable update for authenticated users only" ON "public"."wishlists" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Enable update for authenticated users only" ON "public"."wishs" FOR UPDATE TO "authenticated" USING (true) WITH CHECK (true);



CREATE POLICY "Enable update for users based on receiver_id" ON "public"."friendships" FOR UPDATE USING (true) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "receiver_id"));



ALTER TABLE "public"."friendships" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wish_taken_by_user" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wishlists" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."wishs" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";






ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."friendships";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."profiles";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."wish_taken_by_user";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."wishlists";



ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."wishs";



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";




















































































































































































GRANT ALL ON FUNCTION "public"."delete_user_account"() TO "anon";
GRANT ALL ON FUNCTION "public"."delete_user_account"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."delete_user_account"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_friend_or_friend_of_friend"("_user_id" "uuid", "_friend_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."is_friend_or_friend_of_friend"("_user_id" "uuid", "_friend_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_friend_or_friend_of_friend"("_user_id" "uuid", "_friend_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."nb_wishs_by_user"("user_id" "uuid") TO "anon";
GRANT ALL ON FUNCTION "public"."nb_wishs_by_user"("user_id" "uuid") TO "authenticated";
GRANT ALL ON FUNCTION "public"."nb_wishs_by_user"("user_id" "uuid") TO "service_role";



GRANT ALL ON FUNCTION "public"."update_user_metadata"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_user_metadata"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_user_metadata"() TO "service_role";



























GRANT ALL ON TABLE "public"."friendships" TO "anon";
GRANT ALL ON TABLE "public"."friendships" TO "authenticated";
GRANT ALL ON TABLE "public"."friendships" TO "service_role";



GRANT ALL ON SEQUENCE "public"."friendships_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."friendships_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."friendships_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."users_profiles" TO "anon";
GRANT ALL ON TABLE "public"."users_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."users_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."wish_taken_by_user" TO "anon";
GRANT ALL ON TABLE "public"."wish_taken_by_user" TO "authenticated";
GRANT ALL ON TABLE "public"."wish_taken_by_user" TO "service_role";



GRANT ALL ON TABLE "public"."wishlists" TO "anon";
GRANT ALL ON TABLE "public"."wishlists" TO "authenticated";
GRANT ALL ON TABLE "public"."wishlists" TO "service_role";



GRANT ALL ON SEQUENCE "public"."wishlists_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."wishlists_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."wishlists_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."wishs" TO "anon";
GRANT ALL ON TABLE "public"."wishs" TO "authenticated";
GRANT ALL ON TABLE "public"."wishs" TO "service_role";



GRANT ALL ON SEQUENCE "public"."wishs_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."wishs_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."wishs_id_seq" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























drop extension if exists "pg_net";


  create policy "Auth users can delete their own avatar"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Auth users can update their own avatar"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)))
with check (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Auth users can upload their own avatar"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'avatars'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text)));



  create policy "Authenticated users can alter all wish images gs2bfi_0"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using ((bucket_id = 'wish-images'::text));



  create policy "Authenticated users can alter all wish images gs2bfi_1"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((bucket_id = 'wish-images'::text));



  create policy "Authenticated users can alter all wish images gs2bfi_2"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using ((bucket_id = 'wish-images'::text));



  create policy "Authenticated users can alter all wish images gs2bfi_3"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using ((bucket_id = 'wish-images'::text));



  create policy "Authenticated users can view all avatars"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using ((bucket_id = 'avatars'::text));



